# s0nt3k Knowledgebase Article

**Timestamp:** 2025-10-09 20:00 PDT\
**KBA:** #225510092100\
**Category:** Cryptography (Hex ID: 0x0A9)\
**Subcategory:** Public Key / RSA (Hex ID: 0x1D4)\
**Subject:** RSA in PowerShell — Key Generation, Secret Handling, and Script Encryption\
**Description:** Practical guide to RSA public-key encryption in PowerShell 5.1, including what RSA is, common uses, how to generate RSA key pairs, how to encrypt/decrypt passwords and tokens, and how to encrypt entire scripts and use them securely.\
**Tags:** RSA, CMS, PowerShell 5.1, Certificates, New-SelfSignedCertificate, Protect-CmsMessage, Hybrid-Encryption\

---

## What RSA public-key encryption is (plain-English)

RSA is an **asymmetric** cryptosystem that uses a **public key** (safe to share) and a **private key** (must be kept secret):

* **Encrypt with public key → only private key can decrypt.**
* **Sign with private key → anyone with the public key can verify authenticity.**

Because RSA is slow on big data, it’s commonly used to **encrypt a small random symmetric key** (AES), and **AES** encrypts the actual data. This is called **hybrid encryption**.

---

## Where RSA is used (practical list)

* **End-to-end secret sharing** (e.g., sending a password/token to another admin securely).
* **Configuration secrets at rest** (store encrypted API tokens on disk; only hosts with the private key can decrypt).
* **Secure software updates** (signing manifests/binaries).
* **S/MIME email** (encrypt/sign mail).
* **TLS/Certificates** (server identity and key exchange; RSA certs are common).
* **License files / feature unlock keys** (verify authenticity without exposing the signing key).
* **Encrypted backups of credentials** (transport secrets between environments).
* **Protecting script source** (encrypt the .ps1 contents so only holders of the private key can read/use it).

---

## The PowerShell way: use CMS (Cryptographic Message Syntax)

Windows PowerShell 5.1 includes **Protect-CmsMessage / Unprotect-CmsMessage**, which internally uses RSA via X.509 certificates. This gives you battle-tested crypto without rolling your own.

### 1) Create an RSA key pair (certificate) in your user store

> Default to Windows PowerShell 5.1 compatibility; minimal metadata kept inside each function per your project rules.

```powershell
function New-RsaKeyPair {
<#
.SYNOPSIS
2025-10-09 | Project: Knowledgebase | Fn: 001 | Category: Cryptography | Sub: RSA | v1.0
Create an RSA certificate/key pair for CMS encryption/decryption.
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Subject,                         # e.g. "CN=STK-RSA-ENC-01"
        [int]$KeySize = 4096,
        [string]$CertStore = 'Cert:\CurrentUser\My',
        [string]$ExportDir = "$PSScriptRoot",
        [switch]$ExportPublicOnly                 # If set, skip PFX export
    )

    # Create RSA keypair (non-exportable private key by default for safety)
    $cert = New-SelfSignedCertificate `
        -Subject $Subject `
        -KeyAlgorithm RSA `
        -KeyLength $KeySize `
        -KeyUsage KeyEncipherment,DataEncipherment,DigitalSignature `
        -Type DocumentEncryptionCert `
        -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" `
        -CertStoreLocation $CertStore

    Write-Verbose "Created cert thumbprint: $($cert.Thumbprint)"

    # Export public certificate (.cer) for distribution to encryptors
    $cerPath = Join-Path $ExportDir ("{0}.cer" -f ($Subject -replace '[^\w\-\.=]+','_'))
    Export-Certificate -Cert $cert -FilePath $cerPath | Out-Null

    if (-not $ExportPublicOnly) {
        # (Optional) export PFX (private key) for secure backup/transfer
        $pwd  = Read-Host "Enter password to protect PFX" -AsSecureString
        $pfxPath = Join-Path $ExportDir ("{0}.pfx" -f ($Subject -replace '[^\w\-\.=]+','_'))
        Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $pwd | Out-Null
        Write-Host "Exported PFX (KEEP SECRET): $pfxPath"
    }

    Write-Host "Exported CER (shareable): $cerPath"
    return $cert
}
```

**What you get:**

* A certificate with an RSA key pair in **CurrentUser\My** store.
* A **.cer** (public key only) to share with anyone who needs to **encrypt** for you.
* Optionally a **.pfx** (contains the private key) for secure backup/restoration (protect it strongly; do **not** commit to repos).

---

### 2) Encrypt / Decrypt **secrets** (passwords, tokens) with CMS

Use **Protect-CmsMessage** with the public cert to encrypt. Only the private key holder can decrypt with **Unprotect-CmsMessage**.

```powershell
function Protect-SecretCms {
<#
.SYNOPSIS
2025-10-09 | Project: Knowledgebase | Fn: 002 | Category: Cryptography | Sub: RSA | v1.0
Encrypt a plaintext secret using a recipient RSA (CMS) certificate.
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$PlainText,
        [Parameter(Mandatory)][string]$RecipientCertThumbprint,  # thumbprint in Cert:\CurrentUser\My or LocalMachine\My
        [string]$OutFile                                        # optional path to save encrypted blob
    )

    $cert = Get-Item -LiteralPath ("Cert:\CurrentUser\My\{0}" -f $RecipientCertThumbprint) -ErrorAction SilentlyContinue
    if (-not $cert) {
        $cert = Get-Item -LiteralPath ("Cert:\LocalMachine\My\{0}" -f $RecipientCertThumbprint)
    }

    $enc = Protect-CmsMessage -To $cert -Content $PlainText
    if ($OutFile) { Set-Content -LiteralPath $OutFile -Value $enc -Encoding UTF8 }
    return $enc
}

function Unprotect-SecretCms {
<#
.SYNOPSIS
2025-10-09 | Project: Knowledgebase | Fn: 003 | Category: Cryptography | Sub: RSA | v1.0
Decrypt a CMS secret using the local private key.
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$EncryptedTextOrPath
    )
    if (Test-Path -LiteralPath $EncryptedTextOrPath) {
        $EncryptedTextOrPath = Get-Content -LiteralPath $EncryptedTextOrPath -Raw
    }
    return Unprotect-CmsMessage -Content $EncryptedTextOrPath
}
```

**Usage (encrypt a token/password for storage on disk):**

```powershell
# One-time: create keypair and share .cer to the build/ops machines that will encrypt for you
$cert = New-RsaKeyPair -Subject 'CN=STK-RSA-ENC-01' -Verbose

# On the machine that stores secrets:
$thumb = $cert.Thumbprint
$enc = Protect-SecretCms -PlainText 'super-SECRET-TOKEN-123' -RecipientCertThumbprint $thumb -OutFile "$PSScriptRoot\data\token.cms"

# Later, at runtime (on a machine with the private key installed):
$token = Unprotect-SecretCms -EncryptedTextOrPath "$PSScriptRoot\data\token.cms"
# Use it:
$Headers = @{ Authorization = "Bearer $token" }
```

> Tip: For **SecureString** passwords, convert once to plain text in a controlled session **only to feed the encryption step**, then discard the plaintext variable:

```powershell
$sec = Read-Host "Enter API password" -AsSecureString
$plain = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($sec))
$null  = Protect-SecretCms -PlainText $plain -RecipientCertThumbprint $thumb -OutFile "$PSScriptRoot\data\pwd.cms"
Remove-Variable plain
[GC]::Collect()
```

---

### 3) Using the encrypted secrets in scripts

* **Do not** commit plaintext secrets. Commit only `*.cms`.
* At runtime (on hosts that have the private key), call `Unprotect-SecretCms` to retrieve secrets into **in-memory variables** and use them immediately (e.g., build an `Authorization` header, construct a credential, etc.).
* **Never** re-write decrypted secrets back to disk. Keep them in memory only.

Example constructing a `PSCredential`:

```powershell
$user = 'svc-cybtek'
$pwdPlain = Unprotect-SecretCms -EncryptedTextOrPath "$PSScriptRoot\data\pwd.cms"
$secPwd = ConvertTo-SecureString $pwdPlain -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential($user, $secPwd)
```

---

## Encrypting entire scripts (protecting .ps1 source)

You can encrypt the **entire PowerShell script file** so it’s unusable to anyone lacking the private key.

### Option A (recommended): CMS file encryption

```powershell
# Encrypt a script file to CMS (public key only required here)
$thumb = (Get-ChildItem Cert:\CurrentUser\My | Where-Object Subject -eq 'CN=STK-RSA-ENC-01').Thumbprint
Protect-CmsMessage -To (Get-Item "Cert:\CurrentUser\My\$thumb") -Path "$PSScriptRoot\MyScript.ps1" -OutFile "$PSScriptRoot\MyScript.ps1.cms"
```

Now distribute only `MyScript.ps1.cms`.

To **use** the encrypted script (on a host that has the private key):

```powershell
# Decrypt to memory and invoke
$decrypted = Unprotect-CmsMessage -Content (Get-Content "$PSScriptRoot\MyScript.ps1.cms" -Raw)

# Option 1: Run in the current session (dot-source if it defines functions you need)
Invoke-Expression $decrypted

# Option 2: Dot-source
# . ([ScriptBlock]::Create($decrypted))
```

**Notes & cautions**

* Anyone with the **private key** can decrypt; protect it.
* Consider combining with **code signing** to preserve integrity and origin.
* Avoid writing the decrypted script back to disk; keep execution in memory.

---

## (Optional) Hybrid RSA + AES for arbitrary bytes

If you need raw hybrid crypto (e.g., encrypt files/binaries without CMS), these helper functions do **RSA-wrap of an AES key** and AES-encrypt the payload. Keep them as a fallback; CMS is easier and safer to operate.

```powershell
function Protect-BytesHybridRsa {
<#
.SYNOPSIS
2025-10-09 | Project: Knowledgebase | Fn: 004 | Category: Cryptography | Sub: RSA | v1.0
Encrypt bytes with AES, wrap AES key/IV with recipient RSA public key.
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][byte[]]$Data,
        [Parameter(Mandatory)][string]$RecipientCertThumbprint
    )

    $cert = Get-Item -LiteralPath ("Cert:\CurrentUser\My\{0}" -f $RecipientCertThumbprint) -ErrorAction SilentlyContinue
    if (-not $cert) { $cert = Get-Item -LiteralPath ("Cert:\LocalMachine\My\{0}" -f $RecipientCertThumbprint) }

    $rsa = $cert.GetRSAPublicKey()
    $aes = [System.Security.Cryptography.Aes]::Create()
    $aes.KeySize = 256
    $aes.GenerateKey()
    $aes.GenerateIV()

    $ms = New-Object System.IO.MemoryStream
    $cs = New-Object System.Security.Cryptography.CryptoStream($ms, $aes.CreateEncryptor(), [System.Security.Cryptography.CryptoStreamMode]::Write)
    $cs.Write($Data, 0, $Data.Length); $cs.FlushFinalBlock()
    $cipher = $ms.ToArray()
    $ms.Dispose(); $cs.Dispose()

    $wrappedKey = $rsa.Encrypt($aes.Key, [System.Security.Cryptography.RSAEncryptionPadding]::OaepSHA256)
    $wrappedIV  = $rsa.Encrypt($aes.IV,  [System.Security.Cryptography.RSAEncryptionPadding]::OaepSHA256)

    [PSCustomObject]@{
        Algorithm = 'RSA-OAEP+AES-256-CBC'
        WrappedKey = [Convert]::ToBase64String($wrappedKey)
        WrappedIV  = [Convert]::ToBase64String($wrappedIV)
        Ciphertext = [Convert]::ToBase64String($cipher)
    }
}

function Unprotect-BytesHybridRsa {
<#
.SYNOPSIS
2025-10-09 | Project: Knowledgebase | Fn: 005 | Category: Cryptography | Sub: RSA | v1.0
Unwrap AES key/IV with RSA private key and decrypt bytes.
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$WrappedKeyBase64,
        [Parameter(Mandatory)][string]$WrappedIVBase64,
        [Parameter(Mandatory)][string]$CiphertextBase64
    )

    $wrappedKey = [Convert]::FromBase64String($WrappedKeyBase64)
    $wrappedIV  = [Convert]::FromBase64String($WrappedIVBase64)
    $ciphertext = [Convert]::FromBase64String($CiphertextBase64)

    # Find any RSA private key cert that can decrypt (CurrentUser first)
    $stores = @('Cert:\CurrentUser\My','Cert:\LocalMachine\My')
    $rsaPriv = $null
    foreach ($s in $stores) {
        foreach ($c in Get-ChildItem $s) {
            $k = $c.GetRSAPrivateKey()
            if ($k) { $rsaPriv = $k; break }
        }
        if ($rsaPriv) { break }
    }
    if (-not $rsaPriv) { throw "No RSA private key available for unwrap." }

    $aesKey = $rsaPriv.Decrypt($wrappedKey, [System.Security.Cryptography.RSAEncryptionPadding]::OaepSHA256)
    $aesIV  = $rsaPriv.Decrypt($wrappedIV,  [System.Security.Cryptography.RSAEncryptionPadding]::OaepSHA256)

    $aes = [System.Security.Cryptography.Aes]::Create()
    $aes.Key = $aesKey
    $aes.IV  = $aesIV

    $ms = New-Object System.IO.MemoryStream
    $cs = New-Object System.Security.Cryptography.CryptoStream($ms, $aes.CreateDecryptor(), [System.Security.Cryptography.CryptoStreamMode]::Write)
    $cs.Write($ciphertext, 0, $ciphertext.Length); $cs.FlushFinalBlock()
    $plain = $ms.ToArray()
    $ms.Dispose(); $cs.Dispose()

    return $plain
}
```

> Again: Prefer **CMS** for simplicity and safer key management.

---

## Operational best practices

* **Key custody:** Private keys live only where decryption must occur. Lock down with DPAPI-protected user profiles, hardware-backed keystores (TPM), or HSM if available.
* **Backups:** Export a **PFX** with a strong password and store it in an **offline** vault.
* **Rotation:** Periodically retire old certs; re-encrypt secrets with the new public key.
* **Least exposure:** Decrypt at the last possible moment; keep plaintext in memory, not on disk.
* **Integrity:** Consider **code-signing** your scripts in addition to encrypting content.

---

## Quick recipes (copy/paste)

**Generate a keypair and export public cert:**

```powershell
$cert = New-RsaKeyPair -Subject 'CN=STK-RSA-ENC-01' -Verbose
```

**Encrypt a token to a CMS file:**

```powershell
$thumb = $cert.Thumbprint
Protect-SecretCms -PlainText 'MY-SUPER-TOKEN' -RecipientCertThumbprint $thumb -OutFile "$PSScriptRoot\data\token.cms"
```

**Load and use the token later:**

```powershell
$token = Unprotect-SecretCms -EncryptedTextOrPath "$PSScriptRoot\data\token.cms"
Invoke-RestMethod -Uri https://api.example.com -Headers @{ Authorization = "Bearer $token" }
```

**Encrypt an entire script for distribution:**

```powershell
Protect-CmsMessage -To $cert -Path "$PSScriptRoot\Do-Work.ps1" -OutFile "$PSScriptRoot\Do-Work.ps1.cms"
```

**Run the encrypted script (machine with private key):**

```powershell
$src = Unprotect-CmsMessage -Content (Get-Content "$PSScriptRoot\Do-Work.ps1.cms" -Raw)
Invoke-Expression $src
```

---

If you want, I can adapt these to your **Cybtek STK** directory layout (auto-reading the `DIRECTORIES` file for Logs/Reports/Data) and drop in event/error IDs per your catalog.
